from typing import Dict, List, Any, Optional
import logging

from src.core.realtime_graph.graph.state import OktaState
from src.core.realtime_graph.graph.deps import OktaDeps, get_okta_graph_deps
from src.core.realtime_graph.graph.utils.workflow_executor import WorkflowExecutor

# Import node type definitions for documentation purposes only
# These aren't used for execution anymore, just for metadata
from src.core.realtime_graph.graph.nodes.user_nodes import SearchUsers, GetUserDetails

class OktaGraphManager:
    """
    Manages Okta graph operations.
    
    This class serves as an entry point for executing plans generated by 
    the reasoning agent using the simplified workflow executor approach.
    """
    
    def __init__(self):
        """Initialize the graph manager with available nodes."""
        self._deps_cache = {}
        
        # Registry of node types by name for easy lookup - used only for documentation
        self.node_registry = {
            "SearchUsers": SearchUsers,
            "GetUserDetails": GetUserDetails,
            # Add other node types as needed
        }
        
        # Mapping from node types to workflow executor operations
        self.operation_mapping = {
            "SearchUsers": "search_users",
            "GetUserDetails": "get_user",
            "GetUserFactors": "get_user_factors",
            "GetUserGroups": "get_user_groups", 
            "GetGroupMembers": "get_group_members",
            "SetUserStatus": "set_status",
            "ForEach": "for_each",
            "JoinResults": "join_results"
            # Add more mappings as needed
        }
    
    def get_deps(self, query_id: str = "unknown") -> OktaDeps:
        """
        Get dependencies for the current operation.
        
        Uses a cache to avoid recreating deps for the same query_id.
        
        Args:
            query_id: ID for the current query
            
        Returns:
            OktaDeps instance with logger and client
        """
        if query_id not in self._deps_cache:
            self._deps_cache[query_id] = get_okta_graph_deps(query_id=query_id)
            
        return self._deps_cache[query_id]
    
    def get_node_docs(self) -> Dict[str, str]:
        """
        Get documentation for all available nodes.
        
        Returns:
            Dict mapping node names to their documentation.
        """
        # Use the node registry for nodes we have actual classes for
        docs = {name: node.__doc__ for name, node in self.node_registry.items()}
        
        # Add descriptions for operations that don't have corresponding node classes
        additional_docs = {
            "GetUserFactors": "List all authentication factors for a user by ID",
            "GetUserGroups": "List all groups a user belongs to by user ID",
            "GetGroupMembers": "List all members of a group by group ID",
            "SetUserStatus": "Change a user's status (ACTIVE, SUSPENDED, etc.)",
            "ForEach": "Iterate over a collection and perform an operation on each item",
            "JoinResults": "Combine multiple results in different ways (merge, append, etc.)"
            # Add more as needed
        }
        
        # Update docs with additional operations
        docs.update(additional_docs)
        return docs
    
    async def execute_plan(
        self, 
        nodes: List[Dict[str, Any]],
        query_id: str = "unknown"
    ) -> Dict[str, Any]:
        """
        Execute a sequence of operations.
        
        This method is the main entry point for executing plans generated
        by the reasoning agent.
        
        Args:
            nodes: List of operation definitions
            query_id: ID for the current query
            
        Returns:
            Dictionary with execution results
        """
        # Input validation
        if not isinstance(nodes, list):
            raise ValueError("Nodes must be a list")
            
        # Get dependencies
        deps = self.get_deps(query_id=query_id)
        
        # Create workflow executor
        executor = WorkflowExecutor(
            okta_client=deps.client,  # Use client from deps=deps
            logger=deps.logger,
            query_id=query_id,
            okta_deps=deps
        )
        
        # Transform nodes to step format
        steps = []
        for i, node in enumerate(nodes):
            # Validate each node
            if not isinstance(node, dict):
                raise ValueError(f"Node {i} must be a dictionary")
                
            if "type" not in node:
                raise ValueError(f"Node {i} must have a 'type' field")
                
            # Map node type to operation name (use lowercase version if not in mapping)
            node_type = node["type"]
            operation_name = self.operation_mapping.get(node_type, node_type.lower())
            
            # Create step
            step = {
                "type": operation_name,
                "params": node.get("params", {})
            }
            steps.append(step)
            
        # Execute the workflow
        try:
            result = await executor.execute_workflow(steps)
            return result
        except Exception as e:
            # Log the error but don't expose internal details in the returned error
            deps.logger.error(f"[{query_id}] Workflow execution failed: {str(e)}", exc_info=True)
            return {
                "error": f"Workflow execution failed: {type(e).__name__}",
                "completed": False
            }
    
    def create_node(self, node_type: str, **params) -> Dict[str, Any]:
        """
        Legacy method for backward compatibility.
        
        Args:
            node_type: Type of node to create
            **params: Parameters for the node
            
        Returns:
            Dictionary representing the node
        """
        # Map to operation name if needed
        operation_name = self.operation_mapping.get(node_type, node_type.lower())
        return {"type": operation_name, "params": params}
    
    async def execute_node(
        self, 
        node: Dict[str, Any], 
        state: Optional[OktaState] = None, 
        deps: Optional[OktaDeps] = None, 
        query_id: str = "unknown"
    ) -> Any:
        """
        Legacy method for backward compatibility.
        
        Args:
            node: Node to execute
            state: Optional state object
            deps: Optional dependencies
            query_id: ID for the current query
            
        Returns:
            Execution result wrapped in a simple object
        """
        # Input validation
        if not isinstance(node, dict) or "type" not in node:
            raise ValueError("Invalid node format")
            
        # Get dependencies if not provided
        if deps is None:
            deps = self.get_deps(query_id)
        
        # Create executor
        executor = WorkflowExecutor(
            okta_client=deps.client,
            logger=deps.logger,
            query_id=query_id,
            okta_deps=deps
        )
        
        # Set state if provided
        if state:
            executor.state = state
        
        try:
            # Map to operation name if needed
            node_type = node["type"]
            operation_name = self.operation_mapping.get(node_type, node_type.lower())
            
            # Execute the step
            result = await executor.execute_step(
                operation_name, 
                **(node.get("params", {}))
            )
            return type('NodeResult', (), {'output': result})
        except Exception as e:
            # Log error but return a clean error object
            deps.logger.error(f"[{query_id}] Node execution failed: {str(e)}", exc_info=True)
            error_result = {"error": f"Execution failed: {type(e).__name__}"}
            return type('NodeResult', (), {'output': error_result})

# Create singleton instance
okta_graph_manager = OktaGraphManager()