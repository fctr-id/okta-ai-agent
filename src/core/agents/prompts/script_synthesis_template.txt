### Complete Script Blueprint (CRITICAL - Use This Structure)

This template is loaded when you need to generate the FINAL production script.
Your final production script MUST follow this exact structure.

**⚠️ CRITICAL: DO NOT HALLUCINATE METHODS ON OktaAPIClient**
The `OktaAPIClient` class ONLY has these methods:
- `make_request(endpoint, method, params, entity_label)`
- `start_entity_progress(label, total)`
- `update_entity_progress(label, processed)`
- `complete_entity_progress(label, success)`

**⛔ FORBIDDEN IN SCRIPTS:**
- `client.log_progress(...)` -> DOES NOT EXIST. Use `start_entity_progress` / `update_entity_progress`.
- `log_progress(...)` -> This is an AGENT TOOL for you, not for the script.
- `client.get(...)` -> DOES NOT EXIST. Use `client.make_request(...)`.

**PERFORMANCE REQUIREMENTS:**
- **Use `client.concurrent_limit`** for batch size (never hardcode batch sizes)
- **Use `asyncio.gather()`** for concurrent API calls when fetching data for multiple entities
- **Map results by index**: When using `asyncio.gather`, results are returned in the same order as tasks. Do NOT assume the response object contains the endpoint URL or request metadata.
- **Use progress tracking** (`start_entity_progress(label, total)`, `update_entity_progress`, `complete_entity_progress`) for operations with known totals
- **Use `entity_label` parameter** in `make_request()` for automatic error tracking
- **Remove `max_results=3`** from all API calls in production code

**⚠️ CRITICAL: Progress tracking method signatures:**
```python
# start_entity_progress - Initialize progress tracking
client.start_entity_progress(label="operation_name", total=count)

# update_entity_progress - Update progress (parameter is 'processed', NOT 'current')
client.update_entity_progress(label="operation_name", processed=current_count)

# complete_entity_progress - Mark operation complete
client.complete_entity_progress(label="operation_name", success=True)

# WRONG EXAMPLES - These will cause errors!
# client.start_entity_progress(label="...", total=0, estimated_total=100)  # ❌ estimated_total doesn't exist!
# client.update_entity_progress(label="...", current=50)  # ❌ Parameter is 'processed', NOT 'current'!
```

---

## Complete Python Script Template

```python
#!/usr/bin/env python3
"""
[A clear, one-sentence description of what this script does.]
"""

import asyncio
import json
import sys
from pathlib import Path
from datetime import datetime, timezone

# --- SCRIPT SETUP ---
# 1. Import required modules
#    base_okta_api_client.py is copied to the same directory as this script
#    Environment variables (OKTA_CLIENT_ORGURL, OKTA_API_TOKEN, etc.) are inherited from parent process
from base_okta_api_client import OktaAPIClient
import sqlite3

async def main():
    """Main function to execute the script logic."""
    
    # Ensure consistent encoding for stdout (Critical for Windows)
    sys.stdout.reconfigure(encoding='utf-8')
    
    # --- INITIALIZATION ---
    db_connection = None  # Ensure db_connection is defined in case of connection failure
    try:
        # 2. Initialize SQLite database connection
        #    Robust path detection for Docker and Local environments
        script_dir = Path(__file__).parent
        
        # Try multiple possible paths (Docker first, then local)
        possible_paths = [
            Path("/app/sqlite_db/okta_sync.db"),  # Docker container
            script_dir.parent / "sqlite_db" / "okta_sync.db",  # Local: ../sqlite_db/okta_sync.db
        ]
        
        db_path = None
        for path in possible_paths:
            if path.exists():
                db_path = path
                break
        
        if not db_path:
            print(f"Error: Database not found. Checked paths:", file=sys.stderr)
            for p in possible_paths:
                print(f"  - {p} (exists: {p.exists()})", file=sys.stderr)
            sys.exit(1)
            
        db_connection = sqlite3.connect(str(db_path))
        cursor = db_connection.cursor()
        print(f"Successfully connected to SQLite database at {db_path}")
    except Exception as e:
        print(f"Error: Could not connect to SQLite database: {e}")
        sys.exit(1)
    
    # 3. Initialize the Okta API client (environment variables inherited from parent process)
    client = OktaAPIClient(timeout=180)
    
    # --- DATA FETCHING ---
    try:
        # 4. Define and execute the final, validated SQL query WITHOUT test limits.
        query = """
        [Your validated SQL query WITHOUT LIMIT 3]
        """
        cursor.execute(query)
        
        # 7. Fetch results correctly using fetchall() and access data by index or convert to dict.
        #    ❌ Do NOT use: result.get_all() (that's KuzuDB syntax)
        #    SQLite returns tuples by default. Convert to dicts if needed using cursor.description.
        rows = cursor.fetchall()
        print(f"Found {len(rows)} records in SQLite database.")
        
    except Exception as e:
        print(f"Error querying SQLite database: {e}")
        if db_connection:
            db_connection.close()
        sys.exit(1)
    
    # --- DATA PROCESSING & ORCHESTRATION ---
    # 8. Process database data and make API calls for any data gaps.
    
    # IMPORTANT: For multiple API calls, use CONCURRENT BATCHING for performance
    # Extract entity IDs from database results
    entity_ids = [row[0] for row in rows]  # Adjust index based on your query
    
    # Use client.concurrent_limit for optimal batch size (respects rate limits)
    concurrent_limit = client.concurrent_limit
    all_results = []
    
    # Start progress tracking for percentage-based updates
    client.start_entity_progress("entity_operations", len(entity_ids))
    
    processed_count = 0
    try:
        for i in range(0, len(entity_ids), concurrent_limit):
            chunk = entity_ids[i:i + concurrent_limit]
            
            # Make concurrent API calls with entity_label for automatic error tracking
            tasks = [
                client.make_request(
                    endpoint=f"/api/v1/users/{entity_id}/roles",
                    method="GET",
                    entity_label="entity_operations"  # Enables automatic error counting
                ) for entity_id in chunk
            ]
            chunk_results = await asyncio.gather(*tasks)
            
            # Process results - Map by index since order is preserved
            for idx, response in enumerate(chunk_results):
                # CRITICAL: Check if response is None (failed request)
                if response and response.get("status") == "success":
                    all_results.append({
                        'entity_id': chunk[idx],
                        'data': response.get('data')
                    })
                processed_count += 1
                
                # Update progress (parameter: label, processed - NOT 'current'!)
                client.update_entity_progress("entity_operations", processed_count)
            
            # Small delay between chunks to respect rate limits
            if i + concurrent_limit < len(entity_ids):
                await asyncio.sleep(0.1)
        
        # Complete progress tracking
        client.complete_entity_progress("entity_operations", success=True)
        
    except Exception as e:
        # Complete with error if something goes wrong
        client.complete_entity_progress("entity_operations", success=False)
        raise
    
    # --- FINAL OUTPUT ---
    # 9. Print results as JSON with table headers (REQUIRED FORMAT)
    #    Output MUST include both 'data' and 'headers' for table display
    
    # Generate table-compatible headers from the first result
    headers = []
    if all_results and isinstance(all_results, list) and len(all_results) > 0:
        first_item = all_results[0]
        for key in first_item.keys():
            # Create user-friendly header from field name
            title = key.replace('_', ' ').title()
            headers.append({
                "value": key,        # Property key for data binding
                "text": title,       # Display name
                "sortable": True,    # Enable sorting
                "align": "start"     # Text alignment
            })
    
    # Structure output with data and headers
    output = {
        "data": all_results,
        "headers": headers,
        "count": len(all_results)
    }
    
    print("=" * 80)
    print("QUERY RESULTS")
    print("=" * 80)
    print(json.dumps(output, indent=2, default=str))
    print("=" * 80)
    print(f"Total records: {len(all_results)}")
    print("=" * 80)
    
    # --- CLEANUP ---
    # 10. Close the database connection.
    if db_connection:
        db_connection.close()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Additional Script Patterns

### Pattern 1: API-Only Script (No Database)
If your query only uses API calls and doesn't need the database:

```python
async def main():
    sys.stdout.reconfigure(encoding='utf-8')
    client = OktaAPIClient(timeout=180)
    
    # Your API logic here
    all_results = []
    
    # Output results
    # [Use same output format as above]
```

### Pattern 2: Database-Only Script (No API calls)
If your query only uses SQL and doesn't need API calls:

```python
async def main():
    sys.stdout.reconfigure(encoding='utf-8')
    
    # Database connection
    db_connection = sqlite3.connect(str(db_path))
    cursor = db_connection.cursor()
    
    # Execute query
    cursor.execute(query)
    rows = cursor.fetchall()
    
    # Convert to dicts with column names
    columns = [desc[0] for desc in cursor.description]
    all_results = [dict(zip(columns, row)) for row in rows]
    
    # Output results
    # [Use same output format as above]
    
    db_connection.close()
```

### Pattern 3: Mixed Approach (Database + Targeted API Enrichment)
Most common pattern - fetch core data from DB, enrich with API calls:

```python
async def main():
    # 1. Connect to database and fetch core data
    # 2. Extract entity IDs that need enrichment
    # 3. Use concurrent batching (asyncio.gather) for API calls
    # 4. Merge database data with API results
    # 5. Output combined results
```

---

## Output Format Reference

Remember: Your script must output results in the format specified in Section 1 of the base prompt.

**TABLE FORMAT** (for lists):
```python
output = {
    "display_type": "table",
    "data": all_results,
    "headers": headers,
    "count": len(all_results)
}
```

**MARKDOWN FORMAT** (for summaries):
```python
output = {
    "display_type": "markdown",
    "content": "## Analysis Results\n\n..."
}
```
